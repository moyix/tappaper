\section{Applications}

\subsection{Malware Analysis}

As we will show in Section \ref{sec:eval:subsec:supervised}, TZB can be used for malware analysis in some cases.

\subsection{VM-Based Security and Intrusion Detection}

Little bit about comparing network traffic to VM data?

Tap points for SSL interception without man in the middle (more in evaluation section).

\subsection{Debugging}

Maybe mention booting embedded systems here? Find internal log buffers, etc.


\subsection{Modes of Success and Failure}

TZB is a peculiarly simple, but, we believe, elegant solution to the application RE problem.  
At its heart is an assumption.

\emph{For TZB to work, there must exist a set of memory write instructions, which, if monitored, collectively and temporally comprise the contiguous write of the desired data.}

This might appear limiting, a pesky constraint on an otherwise promising technique.
In our experience, it is not; the assumption holds in a surprising number of situations.
We have therefore come to reformulate the assumption as an observation about programs and systems.  

\emph{Application and system introspection buffers containing useful RE information often exist, and when they do, they are likely to be generated by a set of memory writes which collectively and temporally comprise the contiguous write of the desired data.}

We cannot know for certain that the buffers exists, but there are often clues, such as a log file that contains the information, a window that displays it, or a network packet that contains it. 
And, in our experience, when a buffer exists, TZB can usually find the associated tap points and no RE is required.  

Nevertheless, we encountered two contexts in which TZB had difficulty, and they are worth detailing.  
We saw early success in locating the tap points corresponding to Linux kernel messages, and attempted to locate the corresponding tap points on Windows.
These we did not find, using the output of Event Viewer as training examples as described in Section~\ref{sec:technical:subsec:knownunk}.
This is for the simple reason that the desired introspection buffer does not exist.
The kernel writes a log but it uses a compact binary format with message strings indicated by reference ids.
At best, we could hope to use TZB to find a set of tap points corresponding to the buffer containing this binary kernel log.
This is probably feasible. 
But the result would not be human-readable; we would have to employ the Event Viewer to make sense of it.
In this case, we think a more natural approach would be to use OS introspection techniques like Virtuoso~\cite{Dolan-Gavitt:2011uq}.
Given a few training runs of Event Viewer parsing kernel logs and pretty-printing the information, Virtuoso can assemble a python script that performs the same computation from the hypervisor, which access to guest memory and state.
This script can be used to output human readable guest kernel event information whenever desired.

Another challenge to TZB is that calling context depth is difficult to set for all situations.  
Our definition of tap point in Section~\ref{sec:technical:subsec:tapdef} includes the caller address, that is, one level of context.
This is adequate for correctly separating tap point sets that use the same utility function to write data to memory. 
[WAIT -- isn't this solved by the ``contiguous'' requirement?]
However, there are situations in which more or less context can be required, and sometimes no one level is correct.  
We encountered this situation in trying to locate tap points for Linux kernel messages, in which including the caller to the tap point degraded the results slightly.
We considered various schemes but these seemed unprincipled and tricksy.  
Eventually, we decided that fully automating this aspect of the system was unproductive.
Our goal is simply to locate effective tap points quickly.
In many cases, a few minutes of manual examination of results is all that is required to locate the correct tap point sets or identify when a few sets ought to be merged for better results. 
This is quite reasonable compared with alternative of a fully manual technique.
