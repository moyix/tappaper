\section{Evaluation}
\label{sec:eval}

In this section, we evaluate the efficacy of our various tap point search
strategies, described in Section~\ref{sec:technical}, in finding tap
points useful for introspection. Our experiments are motivated by
real-world introspection applications, and so for each experiment we
describe a typical application for the tap points found. Each experiment
was also generally performed on a variety of different operating sytems,
applications, and architectures in order to evaluate TZB's ability to
handle a diverse range of introspection targets.

\subsection{File Access}
\label{sec:eval:subsec:file}

\begin{table}
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        Target & Tap & ASCII? \\
        \hline
        Debian (amd64) & foo & foo \\ 
        Debian (arm) & foo & foo \\
        Windows 7 (x86) & foo & foo \\
        Haiku (x86) & foo & foo \\
        FreeBSD (x86) & foo & foo \\
        \hline
    \end{tabular}
\caption{Tap points found for file access on different operating
systems. The ``ASCII'' column indicates whether the data was written in
ASCII or UTF-16.}
\label{tbl:file}
\end{table}

Monitoring file accesses is a requirement for many host-based security
applications, including on-access anti-virus scanners. Thus, locating a
tap point at which systemwide file accesses can be observed is of
considerable importance. However, because previous approaches to the
introspection problem~\cite{Dolan-Gavitt:2011uq,Fu:2012fk} are limited
to polling the target for information, they cannot be used in this
scenario.

To find such a tap point, we designed a training run that created and
accessed 100 files, each named after ten successive digits of $\pi$. The
introspection targets chosen for this test were: Debian squeeze (amd64),
Debian squeeze (armel), Windows 7 SP1 32-bit, FreeBSD 9.0, and Haiku R1
Alpha 3. We then searched for tap points that wrote strings matching the
ASCII and UTF-16 encodings of the filenames using the
\texttt{stringsearch} analysis plugin. The UTF-16 encodings were
included because it was known that Windows 7 uses UTF-16 for strings
pervasively, allowing us to surmise that filenames would likely be
UTF-16 encoded. Finally, to validate the tap points found, we looked at
all data written by the tap point to ensure that it contained all of the
filenames accessed, and that no other data was mixed in.

The results are shown in Table~\ref{tbl:file}. \fixme{Add commentary
here when the results are in.}

\subsection{URL Access}
\label{sec:eval:subsec:url}

\begin{table}
    \centering
    \small
    \begin{tabular}{|l|l|l|}
        \hline
        Browser & Caller & PC \\
        \hline
        Deb Epiphany (arm) & unknown & \fixme{unknown} \\
        Deb Epiphany (amd64) & unknown & \fixme{unknown} \\ 
        Win7 IE8 (x86) & \texttt{0x6ed1351a} & \texttt{0x6ece2b43} \\
        Win7 Firefox (x86) & \texttt{0x6bb1284c} & \texttt{0x6b1bb561} \\
        Win7 Opera (x86) &  \texttt{0x6ae819aa} & \texttt{0x6b10434a} \\
        Haiku WebPositive (x86) & \texttt{0x00253721} & \texttt{0x02859583} \\
        \hline
    \end{tabular}
\caption{Tap points found that write the URL typed into the browser by
the user.}
\label{tbl:url}
\end{table}

As with file access, monitoring visited URLs is likely to be of use to
host-based intrusion detection and prevention systems. For example, an
IDS may wish to verify that outgoing requests were initiated by a human
rather than malware on the users's machine, or match URLs visited
against a blacklist of malicious sites. This poses a challenge for
existing introspection solutions, as URL load notification is not
generally exposed by a public API, and the data resides in a user
application (the browser).

To find URL tap points, we created training executions by visiting a set
of three URLs (Google, Facebook, and Bing) the following operating
systems and browsers: Epiphany on Debian squeeze (armel and amd64);
Firefox 16.0.2, Opera 12.10, and Internet Explorer 8.0.7601.17514 on
Windows 7 SP1 (x86); and WebPositive on Haiku (x86). As with the file
access case, we used the \texttt{stringsearch} plugin to search for the
ASCII and UTF-16 representations of the three URLs, and then validated
each tap point found to ensure that it wrote only the desired data. The
results can be seen in Table~\ref{tbl:url}.

\fixme{We need to fix the caller information for amd64 and arm before
we submit. Also hopefully this will make the Opera result better---right
now each URL gets put into its own tap point, probably because of FPO;
the tap listed does contain every URL, but also contains some extra
infomration.}

\subsection{TLS/SSL Master Secrets}
\label{sec:eval:subsec:ssl}

\begin{table*}
    \centering
    \small
    \begin{tabular}{|l|l|l|l|}
        \hline
        Client & Caller & PC & Process \\
        \hline
        Deb OpenSSL (arm) & unknown & \texttt{tls1\_PRF+0x144} & openssl \\
        Deb OpenSSL (amd64) & unknown & \texttt{tls1\_generate\_master\_secret+0x108} & openssl \\ 
        Deb Epiphany (amd64) & unknown & \texttt{md5\_write+302} & epiphany \\ 
        Win7 Chrome (x86) & \texttt{\_NSC\_DeriveKey+0x1241} & \texttt{\_TLS\_PRF+0xa0} & chrome.exe \\
        Win7 IE8 (x86) & \texttt{\_Tls1ComputeMasterKey@32+0x57} & \texttt{\_PRF@40} & lsass.exe \\
        Win7 Firefox (x86) & unknown & \texttt{\_TLS\_PRF+0xbb} & firefox.exe \\
        Win7 Opera (x86) & \texttt{Opera.dll+0x2eb06e} & \texttt{Opera.dll+0x50251} & opera.exe \\
        \hline
    \end{tabular}
\caption{Tap points found that write the SSL/TLS master secret for each
SSL/TLS connection. These keys can be used to perform transparent
interception of SSL traffic without man-in-the-middle. Note that for
readability we have reported the symbolic names found using debug
symbols (where available); however, this functionality is not a
necessary part of TZB.}
\label{tbl:ssl}
\end{table*}

Monitoring SSL/TLS-encrypted traffic is a classic problem for intrusion
detection systems. Currently, hypervisor- or network- based IDSes that
wish to analyze encrypted traffic must perform a man-in-the-middle
attack on the connection, presenting a false server certificate to the
client. Not only does this require the client to cooperate by trusting
certificates signed by the intrusion detection system, it also takes
control of the certificate verification process out of the hands of the
client---a dangerous step, given that many existing SSL/TLS interception
proxies have a history of certificate trust
vulnerabilities~\cite{JarmocBHEU2012}.

Instead of a man-in-the-middle attack, we can instead use TZB to find a
tap point that reads or writes the SSL/TLS master secret for each
encrypted connection. Because this secret must be generated for each
SSL/TLS connection, if we can find such a tap point, it can then be
provided to the IDS to decrypt and, if necessary, modify the content of
the SSL stream.

To find the location of these tap points, we a modified copy of
OpenSSL's \texttt{s\_server} utility that prints out the SSL/TLS master
key any time a connection is made. We then recorded executions in which
we visited the server with each of our tested SSL clients, and noted the
SSL/TLS master secret. Finally, we used \texttt{stringsearch} to search
for a tap point that wrote the master key, and verified that the tap
wrote exactly one master key per connection. For this test, we used:
OpenSSL s\_client 0.9.8 on Debian squeeze (armel), OpenSSL s\_client
0.9.8 and Epiphany \fixme{version} on Debian squeeze (amd64), and Firefox
16.0.2, Google Chrome 23.0.1271.64, Opera 12.10, and Internet Explorer
8.0.7601.17514 on Windows 7 SP1 (x86). The results are shown in
Table~\ref{tbl:ssl}.

There is one particular point of interest to observe in these results.
In the case of Epiphany on Debian, we found that one level of callstack
information was \emph{not} sufficient, in contrast to the other results
reported here---with only the immediate caller, the tap point contains
more data than just the SSL/TLS master secret. This is because the
version of Epiphany uses SSLv3 to make connections, and the
pseudo-random function (PRF) used in SSLv3 has the form
$MD5(SHA1(\ldots))$. The other implementations instead use TLSv1.0,
where the PRF has the form $MD5(\ldots) \oplus SHA1(\ldots)$. This final
XOR operation is done from a unique program point, so the tap point that
results from it contains only TLS master keys. This points to a
potential downside of using tap points for introspection: it is not
always clear in advance how many levels of call stack information will
be required.

We were succesful in locating tap points for all SSL/TLS clients tested.
We note that uncovering similar information using traditional techniques
would have required significant expertise and reverse engineering of
both open source and proprietary software.

\subsection{SSL Malware}
\label{sec:eval:subsec:sslmal}

The need to snoop on SSL-encrypted connections arises in malware
analysis as well. Two features distinguish this case from that of
intercepting the traffic of benign SSL clients presented in the previous
section. First, the ability to decrypt the traffic without a man in the
middle is even more important: in contrast to benign clients, we cannot
assume that malware will accept certificates signed by our certificate
authority. Second, we cannot rely on having access to the server's
master secret, as the server is under the attacker's control. This means
that our previous strategy of using a simple string search for the
master secret will not work here.

Instead, we located the tap point in the SSL-enabled malware by creating
a PANDA plugin called \texttt{keyfind} that performs trial decryption on
a packet sent by the malware using each possible 48-byte sequence
written to memory as a key.  Although this is much slower than a string
match, it is the only available option, since the key is not known in
advance.

To test the plugin, we obtained a copy of a version of the Sykipot
trojan released around October 31st, 2012~\cite{sandymal} (MD5:
\texttt{34a1010846c0502f490f17b66fb05a12}). We then created a recording
in which we executed the malware; simultaneously, we captured network
traffic using texttt{tcpdump}. We noted that the malware made several
encrypted connections to \url{https://www.hi-techsolutions.org/}, and
provided one of the encrypted packets from these connections as input to
the \texttt{keyfind} plugin. The plugin found the same tap point as the
Windows 7 IE8 experiment described in the previous section, indicating
that both the malware and IE8 likely use the same underlying system
mechanism to make SSL connections. The key found was able to decrypt the
connections contained in the packet dump.\footnote{The malware also has
a second layer of encryption, which custom and not based on SSL; we did
not attempt to decrypt this second layer.}

\subsection{Finding \texttt{dmesg}}
\label{sec:eval:subsec:dmesg}

System logs are an invaluable resource, both for security and system
administration. In an introspection-based security system, for example,
one might want to find a tap point that contains the system's logs so
that they can be stored securely outside the guest virtual machine.
However, because the format of system logs is particular to each OS, we
need some mechanism that can find tap points that write data that
``looks like'' a log based on an exemplar. The statistical search
described in Section~\ref{sec:technical:subsec:knownunk} is a good fit
for this task: by training on the output of \texttt{dmesg} on one
OS, we can find \texttt{dmesg}-like tap points on other systems.

To locate these system log tap points, we first created a training
exemplar by running the \texttt{dmesg} command on a Debian sid (amd64)
host, and computing the bigram probabilities for the output. We then
created recordings in which we booted five operating systems: Debian
squeeze (armel), Debian squeeze (amd64), Minix R3-2.0 (i386), FreeBSD
9.0-RELEASE (i386), and Haiku R1 Alpha 3 (i386), and computed the same
bigram statistics. We then sorted the tap points seen in each operating
system boot according to their Jensen-Shannon distance from the training
distribution, and manually examined data written by the tap point for
each of the top 10 results in each operating system. Table~\ref{} shows,
for each operating system tested, the tap point that we determined to be
the system log, and its rank in the search results. We can see that in
the \fixme{most cases} the result is in the top \fixme{N}.

We also attempted to find an analogous log message tap point on Windows
7, but were not successful. This is a result of two factors: first,
Windows typically handles strings internally as UTF-16, which means that
our ASCII \texttt{dmesg} training example is not statistically similar
to most tap points that write strings in Windows. Second, the Windows
logging mechanism is not primarily text-based. Instead, it writes logs
in the binary EVT format.~\cite{winevt}

Anecdotally, the ability to uncover a tap point that writes the kernel
logs has also been useful for diagnosing problems when adding support
for new platforms to QEMU. For an unrelated research task, we attempted
to boot the Raspberry Pi~\cite{raspberrypi} kernel inside QEMU, but
found that it hung without displaying any output early on in the boot
process. By locating the \texttt{dmesg} tap point, we discovered that
the last log message printed was ``Calibrating delay loop...''; based on
this we determined that the guest was hung waiting for a timer interrupt
that was not yet implemented in QEMU.

\subsection{Clustering}
\label{sec:eval:subsec:cluster}
